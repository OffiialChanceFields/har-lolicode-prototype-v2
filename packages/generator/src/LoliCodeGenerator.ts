/**
 * @fileoverview LoliCode script generator for OpenBullet 2
 * @module @har2lolicode/generator
 */

import type { SemanticHarEntry } from '@har2lolicode/parser';
import type { DependencyMatrix } from '@har2lolicode/analyzer';
import {
  RequestBlockBuilder,
  KeycheckBlockBuilder,
  ParseBlockBuilder,
  FunctionBlockBuilder
} from './builders';
import { LoliCodeValidator } from './validators/LoliCodeValidator';
import type {
  LoliCodeConfig,
  CustomHeader,
  CustomAssertion,
  VariableExtraction
} from './types';

/**
 * Generate syntactically valid LoliCode from HAR analysis
 */
export class LoliCodeGenerator {
  private readonly requestBuilder: RequestBlockBuilder;
  private readonly keycheckBuilder: KeycheckBlockBuilder;
  private readonly parseBuilder: ParseBlockBuilder;
  private readonly functionBuilder: FunctionBlockBuilder;
  private readonly validator: LoliCodeValidator;

  constructor() {
    this.requestBuilder = new RequestBlockBuilder();
    this.keycheckBuilder = new KeycheckBlockBuilder();
    this.parseBuilder = new ParseBlockBuilder();
    this.functionBuilder = new FunctionBlockBuilder();
    this.validator = new LoliCodeValidator();
  }

  /**
   * Generate complete LoliCode script
   * @param config - Generation configuration
   * @param entries - Filtered HAR entries
   * @param dependencyMatrix - Request dependencies
   * @returns Valid LoliCode script
   * @throws {Error} INVALID_CONFIG - Invalid configuration
   */
  public generate(
    config: LoliCodeConfig,
    entries: SemanticHarEntry[],
    dependencyMatrix: DependencyMatrix
  ): string {
    // Validate configuration
    this.validateConfig(config, entries.length);

    // Sort selected indices by dependency order
    const sortedIndices = this.sortByDependencies(
      config.selectedIndices,
      dependencyMatrix
    );

    // Generate script sections
    const sections: string[] = [];

    // Add header comment
    sections.push(this.generateHeader());

    // Add settings block if provided
    if (config.settings) {
      sections.push(this.generateSettings(config.settings));
    }

    // Generate request blocks
    for (const index of sortedIndices) {
      const entry = entries[index];
      const requestSection = this.generateRequestSection(
        entry,
        index,
        config
      );
      sections.push(requestSection);
    }

    // Add footer
    sections.push(this.generateFooter());

    // Join sections
    const script = sections.join('\n\n');

    // Validate generated script
    const validation = this.validator.validate(script);
    if (!validation.isValid) {
      throw new Error(`Generated invalid LoliCode: ${validation.errors[0]}`);
    }

    return script;
  }

  /**
   * Validate configuration
   */
  private validateConfig(config: LoliCodeConfig, entryCount: number): void {
    if (!config.selectedIndices || config.selectedIndices.length === 0) {
      throw new Error('INVALID_CONFIG: No requests selected');
    }

    for (const index of config.selectedIndices) {
      if (index < 0 || index >= entryCount) {
        throw new Error(`INVALID_CONFIG: Invalid index ${index}`);
      }
    }
  }

  /**
   * Sort indices by dependency order
   */
  private sortByDependencies(
    indices: number[],
    matrix: DependencyMatrix
  ): number[] {
    const sorted: number[] = [];
    const remaining = new Set(indices);
    const added = new Set<number>();

    while (remaining.size > 0) {
      let foundIndependent = false;

      for (const index of remaining) {
        // Check if all dependencies are satisfied
        let canAdd = true;
        for (let j = 0; j < matrix.adjacencyMatrix.length; j++) {
          if (
            matrix.adjacencyMatrix[index][j] === 1 &&
            indices.includes(j) &&
            !added.has(j)
          ) {
            canAdd = false;
            break;
          }
        }

        if (canAdd) {
          sorted.push(index);
          added.add(index);
          remaining.delete(index);
          foundIndependent = true;
        }
      }

      // If no independent node found, break cycle
      if (!foundIndependent && remaining.size > 0) {
        const next = remaining.values().next().value;
        sorted.push(next);
        added.add(next);
        remaining.delete(next);
      }
    }

    return sorted;
  }

  /**
   * Generate header comment
   */
  private generateHeader(): string {
    return `# ═══════════════════════════════════════════════════════════════
# Generated by HAR2LoliCode
# Date: ${new Date().toISOString()}
# Description: Automated script from HAR analysis
# ═══════════════════════════════════════════════════════════════`;
  }

  /**
   * Generate settings block
   */
  private generateSettings(settings: LoliCodeConfig['settings']): string {
    const lines: string[] = ['SETTINGS'];

    if (settings.useProxy) {
      lines.push('  UseProxy: true');
    }

    if (settings.followRedirects !== undefined) {
      lines.push(`  FollowRedirects: ${settings.followRedirects}`);
    }

    if (settings.timeout) {
      lines.push(`  Timeout: ${settings.timeout}`);
    }

    if (settings.retryCount) {
      lines.push(`  RetryCount: ${settings.retryCount}`);
    }

    return lines.join('\n');
  }

  /**
   * Generate request section with all blocks
   */
  private generateRequestSection(
    entry: SemanticHarEntry,
    index: number,
    config: LoliCodeConfig
  ): string {
    const sections: string[] = [];

    // Add section comment
    sections.push(`# ─────────────────────────────────────────────────────────────`);
    sections.push(`# Request ${index + 1}: ${entry.request.method} ${new URL(entry.request.url).pathname}`);
    sections.push(`# ─────────────────────────────────────────────────────────────`);

    // Generate request block
    const requestBlock = this.requestBuilder.build(
      entry,
      config.customHeaders?.[index]
    );
    sections.push(requestBlock);

    // Generate variable extraction if configured
    if (config.variableExtractions?.[index]) {
      for (const extraction of config.variableExtractions[index]) {
        const parseBlock = this.parseBuilder.build(extraction);
        sections.push(parseBlock);
      }
    }

    // Generate assertions/keychecks
    if (config.customAssertions?.[index]) {
      for (const assertion of config.customAssertions[index]) {
        const keycheckBlock = this.keycheckBuilder.build(assertion);
        sections.push(keycheckBlock);
      }
    } else {
      // Default status check
      sections.push(this.keycheckBuilder.buildStatusCheck(entry.response.status));
    }

    // Add delay between requests
    sections.push('FUNCTION Delay "1000"');

    return sections.join('\n');
  }

  /**
   * Generate footer
   */
  private generateFooter(): string {
    return `# ═══════════════════════════════════════════════════════════════
# End of generated script
# ═══════════════════════════════════════════════════════════════`;
  }
}

// Export factory function
export function generateLoliCode(
  config: LoliCodeConfig,
  entries: SemanticHarEntry[],
  dependencyMatrix: DependencyMatrix
): string {
  const generator = new LoliCodeGenerator();
  return generator.generate(config, entries, dependencyMatrix);
}
